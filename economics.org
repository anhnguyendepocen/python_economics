#+Title: Doing economics with python
#+Author: Jan Boone


* Introduction

This is the notebook to accompany the course Applied Economic Analysis at Tilburg University. The idea is to bring economic concepts "alive" by programming them in python. The choice of topics is mainly based on cite:tirole_2017.

* Python packages that we will be using

#+BEGIN_SRC ipython
import pandas as pd
import numpy as np
import pymc3 as pm
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats, optimize
import random

plt.style.use('seaborn')
%matplotlib inline
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# output
: /Users/boone/anaconda3/lib/python3.6/site-packages/h5py/__init__.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
:   from ._conv import register_converters as _register_converters
: 
:END:


* Why do we love the market?

Many (but not all) economists love the market as an organizing institution. This affection for markets is traced back by some to Adam Smith and his "invisible hand". Others basically distrust other organizing institutions like a government. They will point to the fall of communism in the former soviet union.

To understand the advantages of the market, let us consider a very
simple economy. We focus on one type of product and there is an
exogenous endowment of this product (supply) equal to
~number_of_goods~. Further there are ~number_of_agents~ agents who
have a valuation for this good which is randomly drawn from a normal
distribution. An agent can at max. consume one unit of the product and her utility is then given by her valuation. The value of consuming zero units and the additional value of consuming more than one unit equal 0.

The vector ~valuations~ contains for each agent her valuation and we sort this vector such that the first agent has the highest valuation.

#+BEGIN_SRC ipython
number_of_agents = 1000
number_of_goods = 100

valuations = sorted(pm.Normal.dist(100,20).random(size=number_of_agents),reverse = True)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[11]:
:END:

**Question** What is the economic name for the following expression? To answer this question, you need to understand both how indexing works in python and which economic concept is captured by this expression.

#+BEGIN_SRC ipython
print("{0:.2f}".format(valuations[number_of_goods]))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
# output
: 126.71
: 
:END:

Suppose that we have an omniscient social planner who knows the valuation of every agent in the economy. This planner aims to maximize the (unweighted) sum of agents' utilities.

**Question** Calculate the total welfare that this planner can achieve. Denote this value ~max_welfare~.

#+BEGIN_SRC ipython :no export
max_welfare = np.sum(valuations[:number_of_goods])
print("{0:.2f}".format(max_welfare))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[13]:
# output
: 13694.68
: 
:END:

** market outcome

Now we compare the maximum welfare that a planner can achieve with the market outcome.

**Question** Define a function ~demand(p,valuations)~ which has as arguments a price $p$ and a vector of agents' valuations. This function returns the number of agents who are willing to buy the product at price $p$.

#+BEGIN_SRC ipython :no export
def demand(p,valuations):
    return sum(valuations>p)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:
:END:

**Question** Plot supply and the function ~demand~ against price, where we maintain the economic convention of having quantity on the horizontal axis and price on the vertical axis.

#+BEGIN_SRC ipython :no export
range_p = np.arange(60,150)

plt.plot([demand(p,valuations) for p in range_p],range_p, label = "demand")
plt.plot([number_of_goods for p in range_p],range_p, label="supply")
plt.legend()
plt.xlabel("$Q$")
plt.ylabel("$P$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-sOGgSN.png]]
:END:

In order to calculate the equilibrium price, we define a function ~excess_demand~. 

#+BEGIN_SRC ipython
def excess_demand(p,valuations,number_of_goods):
    return demand(p,valuations)-number_of_goods
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:
:END:

#+BEGIN_SRC ipython
price = optimize.fsolve(lambda x: excess_demand(x,valuations,number_of_goods),120)
print(price)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
# output
: [126.78973182]
: 
:END:


1. calculate welfare
2. compare to max. welfare from planner


Now we give ~number_of_goods~ agents one unit of the good. They become suppliers.

#+BEGIN_SRC ipython
random.shuffle(valuations)
valuations_supply = valuations[:number_of_goods]
valuations_demand = valuations[number_of_goods:]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:


#+BEGIN_SRC ipython :no export
def supply(p,valuations):
    return sum(valuations<p)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
:END:

#+BEGIN_SRC ipython :no export
range_p = np.arange(60,150)

plt.plot([demand(p,valuations_demand) for p in range_p],range_p, label = "demand")
plt.plot([supply(p,valuations_supply) for p in range_p],range_p, label="supply")
plt.legend()
plt.xlabel("$Q$")
plt.ylabel("$P$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[31]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-fq8oPh.png]]
:END:


#+BEGIN_SRC ipython
def demand_minus_supply(p,valuations_demand,valuations_supply):
    return demand(p,valuations_demand)-supply(p,valuations_supply)

optimize.fsolve(lambda x: demand_minus_supply(x,valuations_demand,valuations_supply),120)



#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
# text/plain
: array([126.78973182])
:END:


+ calculate welfare



** why do others not love the market?

*** income distribution

define vector income; you can only buy at price $p$ if valuation and income exceed $p$

#+BEGIN_SRC ipython
incomes = pm.Normal.dist(100,20).random(size=number_of_agents)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:



#+BEGIN_SRC ipython
def afford(p,incomes):
    return incomes>p

def wtp(p,valuations):
    return valuations>p

def demand_2(p,valuations,incomes):
    return np.sum(afford(p,incomes)*wtp(p,valuations))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[27]:
:END:


#+BEGIN_SRC ipython
def excess_demand_2(p,valuations,incomes,number_of_goods):
    return demand_2(p,valuations,incomes)-number_of_goods
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:
:END:

#+BEGIN_SRC ipython
price_2 = optimize.fsolve(lambda x: excess_demand_2(x,valuations,incomes,number_of_goods),120)
print(price_2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[35]:
# output
: [109.42355133]
: 
:END:

#+BEGIN_SRC ipython
welfare_2 = np.sum(afford(price_2,incomes)*wtp(price_2,valuations)*valuations)
print(welfare_2)
print(max_welfare)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[39]:
# output
: 11891.938233742447
: 13228.830798358596
: 
:END:


**Question** Show that as income inequality increases, the welfare generated by the market tends to fall.


*** market power

Suppose that we now give all the products to 1 agent who then owns ~number_of_goods~ units of this good. To simplify, we assume that this agent values the good at 0.

**Question** Suppose we use the function ~demand_minus_supply~ defined above to calculate the equilibrium price. Would the equilibrium price increase? Why (not)?


Let's try to model this.

#+BEGIN_SRC ipython
def profit(p,valuations):
    return p*demand(p,valuations)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[40]:
:END:


#+BEGIN_SRC ipython :exports no
range_p = np.arange(0,140)

plt.plot(range_p, [profit(p,valuations) for p in range_p], label = "profit")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[42]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-TfMhVF.png]]
:END:

Profit maximizing price of 80? That is below the equilibrium we calculated above. How is this possible?


**Assignment**

Calculate the profit maximizing price in this case.


#+BEGIN_SRC ipython :exports no
def profit(p,valuations):
    return p*min(demand(p,valuations),number_of_goods)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[43]:
:END:


#+BEGIN_SRC ipython :exports no
range_p = np.arange(120,140)

plt.plot(range_p, [profit(p,valuations) for p in range_p], label = "profit")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[44]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-N1zMfh.png]]
:END:




*** external effects

Monopolist can produce at cost $c*q$. But production leads to an external effect $\gamma*q$. 

#+BEGIN_SRC ipython
valuations = np.array(sorted(pm.Normal.dist(100,20).random(size=number_of_agents),reverse = True))

c = 30
γ = 80
def costs(q):
    return c*q

def externality(q):
    return γ*q

def profit_c(p,valuations):
    return p*demand(p,valuations)-costs(demand(p,valuations))

def welfare_e(p,valuations):
    return np.sum(valuations[:demand(p,valuations)])-costs(demand(p,valuations))-externality(demand(p,valuations))


#+END_SRC

#+RESULTS:
:RESULTS:
# Out[104]:
:END:



#+BEGIN_SRC ipython
welfare_e(150,valuations)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[95]:
# text/plain
: array([-38.90125471, -42.32656699, -43.86471811, -46.33057487,
:        -46.77034567, -46.97122833])
:END:



#+BEGIN_SRC ipython :exports no
range_p = np.arange(60,150)

plt.plot(range_p, [profit_c(p,valuations) for p in range_p], label = "profit")
plt.plot(range_p, [welfare_e(p,valuations) for p in range_p], label = "welfare")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$, welfare")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[108]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-CYBhRc.png]]
:END:


Welfare maximizing price is higher than profit maximizing price. Trade off: market power and externality


* Asymmetric information

** adverse selection

#+BEGIN_SRC ipython
income = 2
cost = 1
ρ = 0.5
def u(x):
    return x**ρ

π = pm.Uniform.dist(0,1).random(size = 100)
π.sort()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[18]:
:END:


#+BEGIN_SRC ipython
π
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:
# text/plain
: array([0.02613068, 0.03501484, 0.04387227, 0.07282616, 0.08209403,
:        0.08459992, 0.0956844 , 0.0966134 , 0.10733789, 0.10835405,
:        0.11081726, 0.11189932, 0.13223737, 0.14519167, 0.16329937,
:        0.16689527, 0.17618135, 0.20935233, 0.21554677, 0.22096428,
:        0.22933792, 0.23117787, 0.23263588, 0.23706161, 0.23780503,
:        0.2793621 , 0.2861838 , 0.30118566, 0.30973485, 0.32070259,
:        0.33127635, 0.33470864, 0.34332961, 0.35581112, 0.35883786,
:        0.36621522, 0.37878151, 0.37955023, 0.38837508, 0.39022998,
:        0.40108122, 0.43366079, 0.43827728, 0.4549867 , 0.45726711,
:        0.47890139, 0.5147354 , 0.52214751, 0.54477481, 0.54707526,
:        0.55041816, 0.55977991, 0.58408444, 0.5856474 , 0.60083386,
:        0.60457908, 0.61199841, 0.6124388 , 0.64014848, 0.64826328,
:        0.64965493, 0.65859258, 0.65914096, 0.69940976, 0.70989257,
:        0.71413377, 0.71779132, 0.73914567, 0.75041427, 0.75719138,
:        0.75954567, 0.76172703, 0.76259265, 0.78501252, 0.78657102,
:        0.78669987, 0.78999253, 0.79108722, 0.81532074, 0.82037314,
:        0.83020993, 0.83698443, 0.85745203, 0.85763788, 0.8587305 ,
:        0.87323247, 0.88835103, 0.89382833, 0.89669496, 0.90050867,
:        0.90138717, 0.90167945, 0.93469491, 0.94183928, 0.94495768,
:        0.96137818, 0.97058739, 0.97176525, 0.97181414, 0.99080787])
:END:


continue here

#+BEGIN_SRC ipython
def insurance_supply(Q):
    return np.mean(π[-Q])*cost

def insurance_demand(σ):
    return np.sum(?????)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[32]:
:END:


#+BEGIN_SRC ipython
insurance_supply(0)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
# text/plain
: 0.026130675891307353
:END:


#+BEGIN_SRC ipython
range_Q = np.arange(1,101,1)
plt.plot(range_Q,[insurance_supply(Q) for Q in range_Q],label="insurance supply")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[34]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-4T0kBf.png]]
:END:




** moral hazard


* Financial crisis


#+BEGIN_SRC ipython
def profit(x):
    return np.mean(np.maximum(x,0))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
:END:





#+BEGIN_SRC ipython  
vector_returns = pm.Normal.dist(-10,100).random(size=1000)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
:END:


#+BEGIN_SRC ipython  
np.mean(vector_returns)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
# text/plain
: -7.579427962699954
:END:


#+BEGIN_SRC ipython  
profit(vector_returns)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
# text/plain
: 35.28327597418695
:END:


Explain what the python does in the following code cell:

#+BEGIN_SRC ipython
v_std = np.arange(0,200,1)
v_returns = [pm.Normal.dist(-10,std).random(size=1000) for std in v_std]
plt.scatter([np.std(vx) for vx in v_returns],[profit(vx) for vx in v_returns])
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-02bjjB.png]]
:END:

Explain the economic intuition of the graph above.


** Why these bonus contracts?



* Labour market: insiders vs outsiders

Morten. Pissarides model

#  ov-highlight-data: KCgxMTg0MyAxMTg1NiAob3YtdHlwZSAicGluayIgb3YtaGlnaGxpZ2h0ZXIgdCBmYWNlICg6YmFja2dyb3VuZCAiUGluayIpKSkp

# Local Variables:
# eval: (ov-highlight-load)
# End:
