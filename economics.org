#+Title: Doing economics with python
#+Author: Jan Boone


* Introduction

This is the notebook to accompany the course Applied Economic Analysis at Tilburg University. The idea is to bring economic concepts "alive" by programming them in python. The choice of topics is mainly based on cite:tirole_2017.

* Python packages that we will be using

#+BEGIN_SRC ipython
import pandas as pd
import numpy as np
import pymc3 as pm
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats, optimize
import random

plt.style.use('seaborn')
%matplotlib inline
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
# output
: /Users/boone/anaconda3/lib/python3.6/site-packages/h5py/__init__.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
:   from ._conv import register_converters as _register_converters
: 
:END:


* Why do we love the market?

Many (but not all) economists love the market as an organizing institution. This affection for markets is traced back by some to Adam Smith and his "invisible hand". Others basically distrust other organizing institutions like a government. They will point to the fall of communism in the former soviet union.

To understand the advantages of the market, let us consider a very
simple economy. We focus on one type of product and there is an
exogenous endowment of this product (supply) equal to
~number_of_goods~. Further there are ~number_of_agents~ agents who
have a valuation for this good which is randomly drawn from a normal
distribution. An agent can at max. consume one unit of the product and her utility is then given by her valuation. The value of consuming zero units and the additional value of consuming more than one unit equal 0.

The vector ~valuations~ contains for each agent her valuation and we sort this vector such that the first agent has the highest valuation.

#+BEGIN_SRC ipython
number_of_agents = 1000
number_of_goods = 100

valuations = sorted(pm.Normal.dist(100,20).random(size=number_of_agents),reverse = True)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[11]:
:END:

**Question** What is the economic name for the following expression? To answer this question, you need to understand both how indexing works in python and which economic concept is captured by this expression.

#+BEGIN_SRC ipython
print("{0:.2f}".format(valuations[number_of_goods]))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
# output
: 126.71
: 
:END:

Suppose that we have an omniscient social planner who knows the valuation of every agent in the economy. This planner aims to maximize the (unweighted) sum of agents' utilities.

**Question** Calculate the total welfare that this planner can achieve. Denote this value ~max_welfare~.

#+BEGIN_SRC ipython :no export
max_welfare = np.sum(valuations[:number_of_goods])
print("{0:.2f}".format(max_welfare))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[13]:
# output
: 13694.68
: 
:END:

** market outcome

Now we compare the maximum welfare that a planner can achieve with the market outcome.

**Question** Define a function ~demand(p,valuations)~ which has as arguments a price $p$ and a vector of agents' valuations. This function returns the number of agents who are willing to buy the product at price $p$.

#+BEGIN_SRC ipython :no export
def demand(p,valuations):
    return sum(valuations>p)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:
:END:

**Question** Plot supply and the function ~demand~ against price, where we maintain the economic convention of having quantity on the horizontal axis and price on the vertical axis.

#+BEGIN_SRC ipython :no export
range_p = np.arange(60,150)

plt.plot([demand(p,valuations) for p in range_p],range_p, label = "demand")
plt.plot([number_of_goods for p in range_p],range_p, label="supply")
plt.legend()
plt.xlabel("$Q$")
plt.ylabel("$P$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-sOGgSN.png]]
:END:

In order to calculate the equilibrium price, we define a function ~excess_demand~. 

#+BEGIN_SRC ipython
def excess_demand(p,valuations,number_of_goods):
    return demand(p,valuations)-number_of_goods
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:
:END:

#+BEGIN_SRC ipython
price = optimize.fsolve(lambda x: excess_demand(x,valuations,number_of_goods),120)
print(price)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
# output
: [126.78973182]
: 
:END:


1. calculate welfare
2. compare to max. welfare from planner


Now we give ~number_of_goods~ agents one unit of the good. They become suppliers.

#+BEGIN_SRC ipython
random.shuffle(valuations)
valuations_supply = valuations[:number_of_goods]
valuations_demand = valuations[number_of_goods:]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:


#+BEGIN_SRC ipython :no export
def supply(p,valuations):
    return sum(valuations<p)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
:END:

#+BEGIN_SRC ipython :no export
range_p = np.arange(60,150)

plt.plot([demand(p,valuations_demand) for p in range_p],range_p, label = "demand")
plt.plot([supply(p,valuations_supply) for p in range_p],range_p, label="supply")
plt.legend()
plt.xlabel("$Q$")
plt.ylabel("$P$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[31]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-fq8oPh.png]]
:END:


#+BEGIN_SRC ipython
def demand_minus_supply(p,valuations_demand,valuations_supply):
    return demand(p,valuations_demand)-supply(p,valuations_supply)

optimize.fsolve(lambda x: demand_minus_supply(x,valuations_demand,valuations_supply),120)



#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
# text/plain
: array([126.78973182])
:END:


+ calculate welfare



** why do others not love the market?

*** income distribution

define vector income; you can only buy at price $p$ if valuation and income exceed $p$

#+BEGIN_SRC ipython
incomes = pm.Normal.dist(100,20).random(size=number_of_agents)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:



#+BEGIN_SRC ipython
def afford(p,incomes):
    return incomes>p

def wtp(p,valuations):
    return valuations>p

def demand_2(p,valuations,incomes):
    return np.sum(afford(p,incomes)*wtp(p,valuations))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[27]:
:END:


#+BEGIN_SRC ipython
def excess_demand_2(p,valuations,incomes,number_of_goods):
    return demand_2(p,valuations,incomes)-number_of_goods
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:
:END:

#+BEGIN_SRC ipython
price_2 = optimize.fsolve(lambda x: excess_demand_2(x,valuations,incomes,number_of_goods),120)
print(price_2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[35]:
# output
: [109.42355133]
: 
:END:

#+BEGIN_SRC ipython
welfare_2 = np.sum(afford(price_2,incomes)*wtp(price_2,valuations)*valuations)
print(welfare_2)
print(max_welfare)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[39]:
# output
: 11891.938233742447
: 13228.830798358596
: 
:END:


**Question** Show that as income inequality increases, the welfare generated by the market tends to fall.


*** market power

Suppose that we now give all the products to 1 agent who then owns ~number_of_goods~ units of this good. To simplify, we assume that this agent values the good at 0.

**Question** Suppose we use the function ~demand_minus_supply~ defined above to calculate the equilibrium price. Would the equilibrium price increase? Why (not)?


Let's try to model this.

#+BEGIN_SRC ipython
def profit(p,valuations):
    return p*demand(p,valuations)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[40]:
:END:


#+BEGIN_SRC ipython :exports no
range_p = np.arange(0,140)

plt.plot(range_p, [profit(p,valuations) for p in range_p], label = "profit")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[42]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-TfMhVF.png]]
:END:

Profit maximizing price of 80? That is below the equilibrium we calculated above. How is this possible?


**Assignment**

Calculate the profit maximizing price in this case.


#+BEGIN_SRC ipython :exports no
def profit(p,valuations):
    return p*min(demand(p,valuations),number_of_goods)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[43]:
:END:


#+BEGIN_SRC ipython :exports no
range_p = np.arange(120,140)

plt.plot(range_p, [profit(p,valuations) for p in range_p], label = "profit")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[44]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-N1zMfh.png]]
:END:

**** solving a standard oligopoly market

solve standard Cournot model; do merger simulation


*** external effects

Monopolist can produce at cost $c*q$. But production leads to an external effect $\gamma*q$. 

#+BEGIN_SRC ipython
valuations = np.array(sorted(pm.Normal.dist(100,20).random(size=number_of_agents),reverse = True))

c = 30
γ = 80
def costs(q):
    return c*q

def externality(q):
    return γ*q

def profit_c(p,valuations):
    return p*demand(p,valuations)-costs(demand(p,valuations))

def welfare_e(p,valuations):
    return np.sum(valuations[:demand(p,valuations)])-costs(demand(p,valuations))-externality(demand(p,valuations))


#+END_SRC

#+RESULTS:
:RESULTS:
# Out[104]:
:END:



#+BEGIN_SRC ipython
welfare_e(150,valuations)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[95]:
# text/plain
: array([-38.90125471, -42.32656699, -43.86471811, -46.33057487,
:        -46.77034567, -46.97122833])
:END:



#+BEGIN_SRC ipython :exports no
range_p = np.arange(60,150)

plt.plot(range_p, [profit_c(p,valuations) for p in range_p], label = "profit")
plt.plot(range_p, [welfare_e(p,valuations) for p in range_p], label = "welfare")
plt.legend()
plt.xlabel("$P$")
plt.ylabel("$\pi$, welfare")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[108]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-CYBhRc.png]]
:END:


Welfare maximizing price is higher than profit maximizing price. Trade off: market power and externality


* Asymmetric information

** adverse selection

#+BEGIN_SRC ipython
income = 1.1
cost = 1
ρ = 0.1
def u(x):
    return x**ρ

π = pm.Uniform.dist(0.0,1.0).random(size = 100)
π.sort()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[49]:
:END:

#+BEGIN_SRC ipython
def insurance_supply(Q):
    return np.mean(π[-Q:])*cost

def insurance_demand(σ):
    return np.sum(u(income-σ)-(π*u(income-cost)+(1-π)*u(income))>0)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[50]:
:END:


#+BEGIN_SRC ipython
range_Q = np.arange(1,101,1)
range_sigma = np.arange(0,1.01,0.01)
plt.plot(range_Q,[insurance_supply(Q) for Q in range_Q],label="insurance supply")
plt.plot([insurance_demand(sigma) for sigma in range_sigma],range_sigma,label="insurance demand")
plt.plot(range_Q,[π[-Q]*cost for Q in range_Q],label="marginal cost")
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[52]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-kXHIqU.png]]
:END:


#+BEGIN_SRC ipython
ρ = 0.2
def u(x):
    return x**ρ

number_of_agents = 50

π = pm.Beta.dist(8,2).random(size = number_of_agents)
π.sort()

def insurance_supply(Q):
    return np.mean(π[-Q:])*cost

def insurance_demand(σ):
    return np.sum(u(income-σ)-(π*u(income-cost)+(1-π)*u(income))>0)
range_Q = np.arange(1,number_of_agents+1,1)
range_sigma = np.arange(0,1.01,0.01)
plt.plot(range_Q,[insurance_supply(Q) for Q in range_Q],label="insurance supply")
plt.plot([insurance_demand(sigma) for sigma in range_sigma],range_sigma,label="insurance demand")
plt.plot(range_Q,[π[-Q]*cost for Q in range_Q],label="marginal cost")
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[54]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-n6UNID.png]]
:END:





** moral hazard: optimal taxation 

#+BEGIN_SRC ipython
number_of_agents = 100
effort_costs = pm.Lognormal.dist(mu=0.0,sd=0.5).random(size=number_of_agents)
def effort(c,τ):
    sol = optimize.minimize(lambda x: -(x*(1-τ)-c*x**2),1)
    return sol.x
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[65]:
:END:

#+BEGIN_SRC ipython
def Welfare(τ,ρ):
    τ_0 = np.mean([τ*effort(c,τ) for c in effort_costs])
    return (np.sum([((1-τ)*effort(c,τ)+τ_0)**ρ for c in effort_costs]))**(1/ρ)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[74]:
:END:

#+BEGIN_SRC ipython
range_tax = np.arange(0,1.1,0.1)
plt.plot(range_tax,[Welfare(τ,-5) for τ in range_tax])
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[86]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-g3Wrka.png]]
:END:



**Question** Use Rawls criterion





* Financial crisis


#+BEGIN_SRC ipython
def profit(x):
    return np.mean(np.maximum(x,0))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
:END:





#+BEGIN_SRC ipython  
vector_returns = pm.Normal.dist(-10,100).random(size=1000)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
:END:


#+BEGIN_SRC ipython  
np.mean(vector_returns)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
# text/plain
: -7.579427962699954
:END:


#+BEGIN_SRC ipython  
profit(vector_returns)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
# text/plain
: 35.28327597418695
:END:


Explain what the python does in the following code cell:

#+BEGIN_SRC ipython
v_std = np.arange(0,200,1)
v_returns = [pm.Normal.dist(-10,std).random(size=1000) for std in v_std]
plt.scatter([np.std(vx) for vx in v_returns],[profit(vx) for vx in v_returns])
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-02bjjB.png]]
:END:

Explain the economic intuition of the graph above.


** Why these bonus contracts?



* Labour market: insiders vs outsiders

Morten. Pissarides model





* Regulation in health care markets




Again, we use data from [[http://www.vektis.nl/index.php/vektis-open-data][Vektis]]. We import the data, which is a 'csv' file with ";" as separator between columns. We also import some libraries.

Then we look at the columns (variables) in the data.

#+BEGIN_SRC ipython
df_2014 = pd.read_csv('data/Vektis Open Databestand Zorgverzekeringswet 2014 - postcode3.csv', sep = ';')

cost_categories_under_deductible = ['KOSTEN_MEDISCH_SPECIALISTISCHE_ZORG', 'KOSTEN_MONDZORG', 'KOSTEN_FARMACIE', 'KOSTEN_HULPMIDDELEN', 'KOSTEN_PARAMEDISCHE_ZORG_FYSIOTHERAPIE', 'KOSTEN_PARAMEDISCHE_ZORG_OVERIG', 'KOSTEN_ZIEKENVERVOER_ZITTEND', 'KOSTEN_ZIEKENVERVOER_LIGGEND', 'KOSTEN_GRENSOVERSCHRIJDENDE_ZORG', 'KOSTEN_GERIATRISCHE_REVALIDATIEZORG', 'KOSTEN_OVERIG']

def get_data_into_shape(df):
    df['health_expenditure_under_deductible'] = df[cost_categories_under_deductible].sum(axis=1)
    df = df.rename_axis({
        'GESLACHT':'sex',
        'LEEFTIJDSKLASSE':'age',
        'GEMEENTENAAM':'MUNICIPALITY',
        'AANTAL_BSN':'number_citizens',
        'KOSTEN_MEDISCH_SPECIALISTISCHE_ZORG':'hospital_care',
        'KOSTEN_FARMACIE':'pharmaceuticals',
        'KOSTEN_TWEEDELIJNS_GGZ':'mental_care',
        'KOSTEN_HUISARTS_INSCHRIJFTARIEF':'GP_capitation',
        'KOSTEN_HUISARTS_CONSULT':'GP_fee_for_service',
        'KOSTEN_HUISARTS_OVERIG':'GP_other',
        'KOSTEN_MONDZORG':'dental care',
        'KOSTEN_PARAMEDISCHE_ZORG_FYSIOTHERAPIE':'physiotherapy',
        'KOSTEN_KRAAMZORG':'maternity_care',
        'KOSTEN_VERLOSKUNDIGE_ZORG':'obstetrics'
    }, axis='columns')
    df.drop(['AANTAL_VERZEKERDEJAREN',
             'KOSTEN_HULPMIDDELEN',
             'KOSTEN_PARAMEDISCHE_ZORG_OVERIG',
             'KOSTEN_ZIEKENVERVOER_ZITTEND',
             'KOSTEN_ZIEKENVERVOER_LIGGEND',
             'KOSTEN_GRENSOVERSCHRIJDENDE_ZORG',
             'KOSTEN_GERIATRISCHE_REVALIDATIEZORG',
             'KOSTEN_OVERIG',
             'KOSTEN_GENERALISTISCHE_BASIS_GGZ',
             'KOSTEN_EERSTELIJNS_ONDERSTEUNING'],inplace=True,axis=1)
    df.drop(df.index[[0]], inplace=True)
    df['sex'] = df['sex'].astype('category')
    df['age'] = df['age'].astype('category')
    df['costs_per_head']=df['health_expenditure_under_deductible']/df['number_citizens']
    df['log_costs_per_head']=np.log(1+df['health_expenditure_under_deductible']/df['number_citizens'])
    df = df[(df['age'] != '90+')]
    df['age'] = df['age'].astype(int)
    return df

df_2014 = get_data_into_shape(df_2014)
df_2014.head()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
# output
: /Users/boone/anaconda3/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2785: DtypeWarning: Columns (1) have mixed types. Specify dtype option on import or set low_memory=False.
:   interactivity=interactivity, compiler=compiler, result=result)
: /Users/boone/anaconda3/lib/python3.6/site-packages/ipykernel/__main__.py:22: FutureWarning: Using 'rename_axis' to alter labels is deprecated. Use '.rename' instead
: 
# text/plain
:   sex  age  POSTCODE_3  number_citizens  hospital_care  pharmaceuticals  \
: 1   M    0         0.0              366     1372209.26         31191.20   
: 2   M    0       101.0              590     1682944.17         25898.73   
: 3   M    0       102.0              295     1553933.53         29514.18   
: 4   M    0       103.0              288      827427.31         19263.79   
: 5   M    0       105.0              998     2965316.12         61610.42   
: 
:    KOSTEN_SPECIALISTISCHE_GGZ  GP_capitation  GP_fee_for_service  GP_other  \
: 1                      285.98        5548.60             5540.05  11525.93   
: 2                    20774.91        9816.63            10130.12  20532.03   
: 3                     7970.01        5317.49             6576.70  17426.30   
: 4                      941.40        5014.97             5708.41  14168.90   
: 5                     4780.48       16842.06            19676.01  43794.06   
: 
:    dental care  physiotherapy  maternity_care  obstetrics  \
: 1       681.02       12150.91             0.0         0.0   
: 2         0.00       17777.00             0.0         0.0   
: 3        21.29       20459.17             0.0         0.0   
: 4         0.00        9098.71             0.0         0.0   
: 5       166.98       42332.18             0.0         0.0   
: 
:    health_expenditure_under_deductible  costs_per_head  log_costs_per_head  
: 1                           1425823.15     3895.691667            8.267883  
: 2                           1753560.87     2972.137068            7.997373  
: 3                           1617184.58     5481.981627            8.609404  
: 4                            865867.07     3006.482882            8.008859  
: 5                           3118357.71     3124.606924            8.047384  

# text/html
#+BEGIN_EXPORT html
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sex</th>
      <th>age</th>
      <th>POSTCODE_3</th>
      <th>number_citizens</th>
      <th>hospital_care</th>
      <th>pharmaceuticals</th>
      <th>KOSTEN_SPECIALISTISCHE_GGZ</th>
      <th>GP_capitation</th>
      <th>GP_fee_for_service</th>
      <th>GP_other</th>
      <th>dental care</th>
      <th>physiotherapy</th>
      <th>maternity_care</th>
      <th>obstetrics</th>
      <th>health_expenditure_under_deductible</th>
      <th>costs_per_head</th>
      <th>log_costs_per_head</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>M</td>
      <td>0</td>
      <td>0.0</td>
      <td>366</td>
      <td>1372209.26</td>
      <td>31191.20</td>
      <td>285.98</td>
      <td>5548.60</td>
      <td>5540.05</td>
      <td>11525.93</td>
      <td>681.02</td>
      <td>12150.91</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1425823.15</td>
      <td>3895.691667</td>
      <td>8.267883</td>
    </tr>
    <tr>
      <th>2</th>
      <td>M</td>
      <td>0</td>
      <td>101.0</td>
      <td>590</td>
      <td>1682944.17</td>
      <td>25898.73</td>
      <td>20774.91</td>
      <td>9816.63</td>
      <td>10130.12</td>
      <td>20532.03</td>
      <td>0.00</td>
      <td>17777.00</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1753560.87</td>
      <td>2972.137068</td>
      <td>7.997373</td>
    </tr>
    <tr>
      <th>3</th>
      <td>M</td>
      <td>0</td>
      <td>102.0</td>
      <td>295</td>
      <td>1553933.53</td>
      <td>29514.18</td>
      <td>7970.01</td>
      <td>5317.49</td>
      <td>6576.70</td>
      <td>17426.30</td>
      <td>21.29</td>
      <td>20459.17</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1617184.58</td>
      <td>5481.981627</td>
      <td>8.609404</td>
    </tr>
    <tr>
      <th>4</th>
      <td>M</td>
      <td>0</td>
      <td>103.0</td>
      <td>288</td>
      <td>827427.31</td>
      <td>19263.79</td>
      <td>941.40</td>
      <td>5014.97</td>
      <td>5708.41</td>
      <td>14168.90</td>
      <td>0.00</td>
      <td>9098.71</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>865867.07</td>
      <td>3006.482882</td>
      <td>8.008859</td>
    </tr>
    <tr>
      <th>5</th>
      <td>M</td>
      <td>0</td>
      <td>105.0</td>
      <td>998</td>
      <td>2965316.12</td>
      <td>61610.42</td>
      <td>4780.48</td>
      <td>16842.06</td>
      <td>19676.01</td>
      <td>43794.06</td>
      <td>166.98</td>
      <td>42332.18</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>3118357.71</td>
      <td>3124.606924</td>
      <td>8.047384</td>
    </tr>
  </tbody>
</table>
</div>
#+END_EXPORT
:END:




#+BEGIN_SRC ipython
costs_per_sex_age = df_2014.groupby(['sex','age'])['costs_per_head'].mean()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
:END:


** matplotlib

Then we can plot this distribution of health care expenditure per head with age for males and females.

#+BEGIN_SRC ipython
import matplotlib.pyplot as plt
plt.style.use('seaborn')
fig = plt.figure()
ax = costs_per_sex_age['M'].plot()
ax = costs_per_sex_age['V'].plot()
ax.set_xlabel('age')
ax.set_ylabel('costs per head')
ax.set_title('average costs per age and sex')
ax.legend(['male','female'])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:


# text/plain
: <Figure size 576x396 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-TwMCQq.png]]
:END:


*** reversing the probability distributions

Above we used ~pymc3~ to generate vectors of productivities, valuations, incomes etc. using probability distributions. Here we go the "other way around". We have here distributions of health care expenditures per head and we want to identify the distributions where these come from.

#+BEGIN_SRC ipython
df_2014.query('sex=="M" & age=="70"')['log_costs_per_head'].hist(bins=50)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[7]:


# text/plain
: <Figure size 576x396 with 1 Axes>

# image/png
[[file:obipy-resources/48de63ba873b65759d43f92c5813c7a6-7KO2im.png]]
:END:


We will assume that for each age and sex category ~costs_per-head~ are normally distributed.

We focus on modelling male (log) costs


#+BEGIN_SRC ipython :async

log_costs_per_age_male = df_2014[df_2014['sex']=='M'].groupby(['age'])['log_costs_per_head'].mean()

log_costs_per_head = df_2014[df_2014['sex']=='M'].log_costs_per_head.values
age = df_2014[df_2014['sex']=='M'].age.values


with pm.Model() as model:
    
    μ = pm.Normal('μ', 8, 3, shape=len(set(age)))
    σ = pm.HalfCauchy('σ', 4, shape=len(set(age)))
    z = pm.Normal('z', μ[age], σ[age], observed=log_costs_per_head)

#+END_SRC

#+RESULTS:
:RESULTS:
1 - a1d0f4fa-c439-4a6f-870f-f917348861fb <output>
:END:


#+BEGIN_SRC ipython :async
with model:
    trace = pm.sample(4000,step = pm.Metropolis(),start = pm.find_MAP())
#+END_SRC

#+RESULTS:
:RESULTS:
2 - 2ca52af1-6b20-417c-a986-93794442b0b4 <output>
:END:


#+BEGIN_SRC ipython
summary = pm.summary(trace, varnames=['μ'])

pm.plot_posterior(trace, varnames=['μ'],ref_val = log_costs_per_age_male.values)

#+END_SRC


#+BEGIN_SRC ipython
plt.plot(summary['mean'].values,label='calculated means')
plt.plot(log_costs_per_age_male,'o',label='observed means')
plt.legend()
#+END_SRC



compare average at 17 and 19 and redo this for another year...




** using python for empirical research



*** API's to get data






#  ov-highlight-data: KCgxMTg0MyAxMTg1NiAoZmFjZSAoOmJhY2tncm91bmQgIlBpbmsiKSBvdi1oaWdobGlnaHRlciB0IG92LXR5cGUgInBpbmsiKSkp

# Local Variables:
# eval: (ov-highlight-load)
# End:

